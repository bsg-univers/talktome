<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Speech Notes</title>
<style>
  :root { --bg:#f6eaf4; --btn:#5b4b4f; --btnDisabled:#a79aa0; --border:#4d3f43; }

  html, body { height: 100%; }
  body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); }

  .wrap {
    max-width: 750px;
    margin: 0 auto;
    padding: 14px 12px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-sizing: border-box;
  }

  .row { display:flex; gap:10px; }

  /* Compact buttons */
  button {
    flex:1;
    padding:10px 10px;
    border:2px solid var(--border);
    background:var(--btn);
    color:#fff;
    font-weight:400;
    letter-spacing:.4px;
    border-radius:6px;
    cursor:pointer;
    font-size: 14px;
    line-height: 1.1;
    min-height: 40px;
  }
  button[disabled] { background:var(--btnDisabled); cursor:not-allowed; opacity:.55;}

  /* Make PLAY a normal-height single row */
  .row.single button { flex:1; }

  .status { margin: 0 2px; color:#3b2d31; font-size: 13px; }

  .box {
    border:2px solid var(--border);
    border-radius:6px;
    overflow:hidden;
    background:#fff;
    flex: 1;                 /* take remaining space */
    display: flex;
    flex-direction: column;
    min-height: 0;            /* important so textarea can shrink properly */
  }

  .boxHeader{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px;
    background:var(--btn);
    color:#fff;
    font-weight:700;
    cursor:pointer;
    user-select:none;
    flex: 0 0 auto;
  }
  .boxHeader small { opacity:.85; font-weight:600; }

  textarea{
    width:100%;
    flex: 1;                 /* fill box */
    min-height: 0;
    resize:none;             /* keeps layout stable on mobile */
    border:0;
    outline:0;
    padding:10px;
    font-size:17px;
    line-height:1.45;
    overflow:auto;
    box-sizing:border-box;
  }

  /* Compact language selector */
  #lang{
    width:100%;
    padding:10px;
    border:2px solid var(--border);
    border-radius:6px;
    font-size:14px;
    background:#fff;
  }
</style>

</head>
<body>
  <div class="wrap">
    <div class="row">
      <select id="lang" style="flex:1;padding:12px;border:2px solid var(--border);border-radius:6px;font-size:16px;">
        <option value="fr-FR">Français</option>
        <option value="en-US">English (US)</option>
        <option value="en-GB">English (UK)</option>
        <option value="es-ES">Español</option>
        <option value="de-DE">Deutsch</option>
      </select>
    </div>

    <div class="row">
      <button id="startBtn">START</button>
      <button id="stopBtn">STOP</button>
    </div>

    <div class="row single">
      <button id="playBtn">PLAY</button>
    </div>

    <div class="row">
      <button id="pauseBtn">PAUSE</button>
      <button id="resumeBtn">RESUME</button>
    </div>

    <div class="status" id="status">Idle.</div>

    <div class="box">
      <div class="boxHeader" id="editToggle">
        <span>✎</span>
        <small id="editState">OFF</small>
      </div>
      <textarea id="text" placeholder="Transcript appears here..." readonly></textarea>
    </div>
  </div>

<script>
(() => {
  // ---------- UI ----------
  const langEl = document.getElementById('lang');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const statusEl = document.getElementById('status');
  const textEl = document.getElementById('text');
  const editToggle = document.getElementById('editToggle');
  const editState = document.getElementById('editState');

  let segmentStart = 0; // index in committedText where the current record segment starts (Start/Resume)


  // --- Auto-scroll control ---
let userPinnedToBottom = true;

function isNearBottom(el, threshold = 24) {
  return (el.scrollHeight - el.scrollTop - el.clientHeight) < threshold;
}

textEl.addEventListener("scroll", () => {
  // If user scrolls up, stop forcing autoscroll.
  userPinnedToBottom = isNearBottom(textEl);
});


  function setStatus(msg) { statusEl.textContent = msg; }

  // ---------- Speech Recognition (prefix-growth safe) ----------
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let recog = null;

  let recState = "idle";                 // "idle" | "listening"
  let shouldClearOnNextStart = true;

  let committedText = "";                // what we keep
  let interimText = "";                  // live interim

  let manualEnd = false;                 // prevents auto-restart on pause/stop

  // The key fix:
  // Many mobile engines output final results as an ever-growing prefix of the whole utterance.
  // Track the last final hypothesis and only append the NEW suffix.
  let lastFinalHypothesis = "";          // normalized text of last final result in current stream

  function normalize(s) {
    return (s || "").replace(/\s+/g, " ").trim();
  }

 function renderTranscript() {
  const shouldStick = userPinnedToBottom && textEl.readOnly; // don't fight user while editing
  textEl.value = (committedText + interimText).trimStart();

  if (shouldStick) {
    // keep newest text visible
    textEl.scrollTop = textEl.scrollHeight;
  }
}


  function ensureSpace(base) {
    return base.length > 0 && !/\s$/.test(base) ? " " : "";
  }

  // Returns how many chars of "b" are already covered by suffix of "a"
  // (max overlap where end(a) == start(b))
  function overlapSuffixPrefix(a, b) {
    const max = Math.min(a.length, b.length);
    for (let k = max; k > 0; k--) {
      if (a.slice(-k) === b.slice(0, k)) return k;
    }
    return 0;
  }

  function appendDeltaFromFinal(finalTextRaw) {
    const hyp = normalize(finalTextRaw);
    if (!hyp) return;

    const prev = lastFinalHypothesis;

    // Case 1: growing prefix within the current stream
    if (prev && hyp.startsWith(prev)) {
      const delta = normalize(hyp.slice(prev.length));
      if (delta) committedText += ensureSpace(committedText) + delta;
      lastFinalHypothesis = hyp;
      return;
    }

    // Case 2: regression (engine emitted shorter hypothesis); ignore
    if (prev && prev.startsWith(hyp)) return;

    // Case 3: restart/resegmentation
    // IMPORTANT: only dedupe/overlap within the current segment (since last Resume/Start),
    // so legitimate repetition across segments (e.g. "...ça va" then "Ça va bien") is preserved.
    const segmentText = committedText.slice(segmentStart);
    const segmentNorm = normalize(segmentText);

    // If the segment already ends with this hypothesis, it's a duplicate within this segment
    if (segmentNorm && segmentNorm.endsWith(hyp)) {
      lastFinalHypothesis = hyp;
      return;
    }

    // Overlap only against segment text
    const ov = overlapSuffixPrefix(segmentNorm, hyp);
    const tail = normalize(hyp.slice(ov));
    if (tail) committedText += ensureSpace(committedText) + tail;

    lastFinalHypothesis = hyp;
  }


  function ensureRecognition() {
    if (!SpeechRecognition) return null;
    if (recog) return recog;

    recog = new SpeechRecognition();
    recog.continuous = true;
    recog.interimResults = true;
    recog.maxAlternatives = 1;

    recog.onresult = (event) => {
      let interim = "";

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const r = event.results[i];
        const t = r[0]?.transcript ?? "";
        if (!t) continue;

        if (r.isFinal) {
          appendDeltaFromFinal(t);
        } else {
          interim += t;
        }
      }

      interimText = interim;
      renderTranscript();
    };

    recog.onerror = (e) => setStatus(`Recognition error: ${e.error}`);

    recog.onend = () => {
      if (recState === "listening" && !manualEnd) {
        setTimeout(() => {
          if (recState === "listening") {
            try { recog.start(); } catch (_) {}
          }
        }, 150);
      }
      manualEnd = false;
    };

    return recog;
  }

  function startRecognition({ clear }) {
    const r = ensureRecognition();
    if (!r) {
      setStatus("Speech recognition not supported in this browser. Use MediaRecorder+server fallback for full mobile support.");
      return;
    }

    r.lang = langEl.value;

    if (clear) {
      committedText = "";
      interimText = "";
      lastFinalHypothesis = "";
      segmentStart = 0;
      renderTranscript();
    } else {
      if (!textEl.readOnly) {
        committedText = normalize(textEl.value);
        interimText = "";
        renderTranscript();
      }

      if (committedText && !/\s$/.test(committedText)) {
        committedText += " ";
        renderTranscript();
      }

      segmentStart = committedText.length;
      lastFinalHypothesis = "";
    }

    userPinnedToBottom = true;

    recState = "listening";
    manualEnd = false;
    setStatus("Listening…");
    try { r.start(); } catch (_) {}
  }

  function pauseRecognition() {
    if (!recog) return;
    manualEnd = true;
    try { recog.stop(); } catch (_) {}
    recState = "idle";
    interimText = "";
    // Keep lastFinalHypothesis so resume continues deltas safely
    renderTranscript();
    setStatus("Paused.");
  }

 function stopRecognitionAndClear() {
  if (recog) {
    manualEnd = true;
    try { recog.stop(); } catch (_) {}
  }
  recState = "idle";
  committedText = "";
  interimText = "";
  lastFinalHypothesis = "";
  segmentStart = 0;          // ✅ add this
  renderTranscript();
  setStatus("Stopped. Cleared.");
  shouldClearOnNextStart = true;
  userPinnedToBottom = true; // ✅ optional but recommended (follow again next time)
}

  // ---------- Speech Synthesis ----------
  let currentUtterance = null;

  function getSelectedOrAllText() {
    const start = textEl.selectionStart;
    const end = textEl.selectionEnd;
    if (typeof start === "number" && typeof end === "number" && end > start) {
      return textEl.value.slice(start, end);
    }
    return textEl.value;
  }

  function speakText(text) {
    if (!text.trim()) return;

    window.speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(text);
    u.lang = langEl.value;

    u.onend = () => {
      currentUtterance = null;
      playBtn.textContent = "PLAY";
      setStatus(recState === "listening" ? "Listening…" : "Idle.");
    };
    u.onerror = () => {
      currentUtterance = null;
      playBtn.textContent = "PLAY";
      setStatus("TTS error.");
    };

    currentUtterance = u;
    playBtn.textContent = "STOP";
    setStatus("Speaking…");
    window.speechSynthesis.speak(u);
  }

  // ---------- Buttons ----------
  startBtn.onclick = () => {
    const clear = shouldClearOnNextStart;
    shouldClearOnNextStart = false;
    startRecognition({ clear });
  };

  stopBtn.onclick = () => {
    stopRecognitionAndClear();

    window.speechSynthesis.cancel();
    currentUtterance = null;
    playBtn.textContent = "PLAY";
  };

  pauseBtn.onclick = () => {
    if (recState === "listening") pauseRecognition();

    if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
      window.speechSynthesis.pause();
      setStatus("Paused.");
    } else if (recState !== "listening") {
      setStatus("Paused.");
    }
  };

  resumeBtn.onclick = () => {
    if (recState !== "listening") startRecognition({ clear: false });

    if (window.speechSynthesis.paused) {
      window.speechSynthesis.resume();
      setStatus("Speaking…");
    }
  };

  playBtn.onclick = () => {
    if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
      window.speechSynthesis.cancel();
      currentUtterance = null;
      playBtn.textContent = "PLAY";
      setStatus(recState === "listening" ? "Listening…" : "Idle.");
      return;
    }
    speakText(getSelectedOrAllText());
  };

  // ---------- Edit toggle ----------
  let editing = false;
  editToggle.onclick = () => {
    editing = !editing;
    textEl.readOnly = !editing;
    editState.textContent = editing ? "ON" : "OFF";

    // optional: stop recognition while editing
    if (editing && recState === "listening") {
      pauseRecognition();
    }

    if (editing) textEl.focus();
  };

  // ---------- Init ----------
  setStatus("Idle.");
})();
</script>


</body>
</html>
