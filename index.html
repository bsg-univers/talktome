<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- App-like viewport on mobile (important for Android + notch safe areas) -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#5b4b4f" />
  <title>Speech Notes</title>

  <!-- PWA (GitHub Pages-safe relative path) -->
  <link rel="manifest" href="./manifest.webmanifest" />

  <style>
    :root {
      --bg:#f6eaf4;
      --btn:#5b4b4f;
      --btnDisabled:#a79aa0;
      --border:#4d3f43;
      --text:#3b2d31;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }

    /* Main app container */
    .wrap {
      max-width: 750px;
      margin: 0 auto;

      height: 100dvh;                   /* correct visible height on mobile */
      height: 100vh;                    /* fallback */

      display: flex;
      flex-direction: column;
      gap: 8px;

      padding: calc(10px + env(safe-area-inset-top))
               calc(10px + env(safe-area-inset-right))
               calc(10px + env(safe-area-inset-bottom))
               calc(10px + env(safe-area-inset-left));

      box-sizing: border-box;
      min-height: 0;
    }

    /* Allow flex children to shrink properly */
    .wrap > * { min-height: 0; }

    .row { display:flex; gap:10px; }

    /* Language select */
    #lang{
      width:100%;
      padding:10px;
      border:1.5px solid var(--border);
      border-radius:10px;
      font-size:14px;
      background:#fff;
      box-sizing:border-box;
    }

    /* Compact buttons */
    button {
      flex: 1;
      padding: 10px 10px;
      border: 2px solid var(--border);
      background: var(--btn);
      color: #fff;

      font-weight: 400;
      letter-spacing: .4px;

      border-radius: 8px;
      cursor: pointer;

      font-size: 14px;
      line-height: 1.1;

      min-height: 40px;

      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    button[disabled] {
      background: var(--btnDisabled);
      cursor: not-allowed;
      opacity: .55;
    }

    .row.single button { flex:1; }

    .status {
      margin: 0 2px;
      font-size: 13px;
      line-height: 1.2;
    }

    /* Text area fills remaining space */
    .box {
      border: 2px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: #fff;

      flex: 1 1 auto;
      min-height: 0;

      display: flex;
      flex-direction: column;
    }

    .boxHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;

      padding: 10px 12px;
      background: var(--btn);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      user-select: none;

      flex: 0 0 auto;
    }

    .boxHeader small { opacity: .85; font-weight: 600; }

    textarea{
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;

      resize: none;
      border: 0;
      outline: 0;

      padding: 12px;
      font-size: 17px;
      line-height: 1.45;

      overflow: auto;
      box-sizing: border-box;

      -webkit-overflow-scrolling: touch;
    }

    /* Mobile tweaks */
    @media (max-width: 600px) {
      .row { gap: 8px; }
      button {
        min-height: 36px;
        font-size: 13px;
        padding: 9px 8px;
        border-radius: 10px;
      }
      #lang {
        padding: 9px;
        font-size: 13px;
        border-radius: 10px;
      }
      textarea {
        font-size: 16px;
        padding: 10px;
      }
    }
    .box { position: relative; } /* add this if not already */

#emptyState{
  position:absolute;
  inset: 52px 0 0 0; /* below the header; adjust if your header height differs */
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: 14px;
  pointer-events:none;
  opacity: 0.9;
}

#emptyState img{
  width: 120px;
  height: auto;
  opacity: 0.9;
}

#emptyState .emptyText{
  font-size: 14px;
  color: rgba(59,45,49,0.85); /* your theme text */
}

/* Special style for PLAY button */
#playBtn {
  background: white;   /* same pink as app background */
  color: var(--btn);       /* brown text */
  border: 1.5px solid var(--border);
  font-weight: 600;
}

/* Optional: slightly darker on press */
#playBtn:active {
  filter: brightness(0.97);
}


  </style>
</head>

<body>
  <div class="wrap">
    <div class="row">
      <select id="lang">
        <option value="fr-FR">Français</option>
        <option value="en-US">English (US)</option>
        <option value="en-GB">English (UK)</option>
        <option value="es-ES">Español</option>
        <option value="de-DE">Deutsch</option>
      </select>
    </div>

    <div class="row">
      <button id="startBtn">START</button>
      <button id="stopBtn">STOP</button>
    </div>

    <div class="row single">
      <button id="playBtn">PLAY</button>
    </div>

    <div class="row">
      <button id="pauseBtn">PAUSE</button>
      <button id="resumeBtn">RESUME</button>
    </div>

    <div class="status" id="status">ᓚᘏᗢ</div>

    <div class="box">
  <div class="boxHeader" id="editToggle">
    <span>✎</span>
    <small id="editState">OFF</small>
  </div>

  <!-- Empty state overlay -->
  <div id="emptyState" aria-hidden="true">
    <img src="./micro.png" alt="" />
    <div class="emptyText">Your speech blooms here</div>
  </div>

  <textarea id="text" readonly></textarea>
</div>

  </div>

  <script>
  (() => {
    // ---------- UI ----------
    const langEl = document.getElementById('lang');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const statusEl = document.getElementById('status');
    const textEl = document.getElementById('text');
    const editToggle = document.getElementById('editToggle');
    const editState = document.getElementById('editState');

    const emptyStateEl = document.getElementById("emptyState");

    let isComposing = false;

    textEl.addEventListener("compositionstart", () => { isComposing = true; });
    textEl.addEventListener("compositionend", () => { isComposing = false; });
    
    // Optional but helpful: while editing, keep committedText up-to-date as user types
    textEl.addEventListener("input", () => {
      if (!textEl.readOnly) {
        // Don't renderTranscript() here (it would fight the user); just keep model in sync.
        committedText = textEl.value;  // keep raw edits
      }
    });


    function updateEmptyState() {
      const hasText = normalize(textEl.value).length > 0;
    
      // Show only when empty AND not in edit mode (readOnly = true)
      const show = !hasText && textEl.readOnly;
    
      emptyStateEl.style.display = show ? "flex" : "none";
    }



    function setStatus(msg) { statusEl.textContent = msg; }

    // ---------- PWA (GitHub Pages-safe) ----------
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js").catch(() => {});
      });
    }

    // ---------- Auto-scroll control ----------
    let userPinnedToBottom = true;

    function isNearBottom(el, threshold = 24) {
      return (el.scrollHeight - el.scrollTop - el.clientHeight) < threshold;
    }

    textEl.addEventListener("scroll", () => {
      userPinnedToBottom = isNearBottom(textEl);
    });

    // ---------- Speech Recognition (mobile-safe + resume-safe) ----------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recog = null;

    let recState = "idle";                 // "idle" | "listening"
    let shouldClearOnNextStart = true;

    let committedText = "";
    let interimText = "";

    let manualEnd = false;

    let lastFinalCanonTokens = [];
    let segmentStart = 0;                  // boundary to allow repeats across Pause/Resume

    function rawTokens(s) {
  return (s || "").trim().split(/\s+/).filter(Boolean);
}

function canonToken(t) {
  return (t || "")
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase()
    .replace(/[^\p{L}\p{N}]+/gu, "");
}

function canonTokensFromText(s) {
  return rawTokens(s).map(canonToken).filter(Boolean);
}


function startsWithTokens(full, prefix) {
  if (prefix.length > full.length) return false;
  for (let i = 0; i < prefix.length; i++) if (full[i] !== prefix[i]) return false;
  return true;
}

function endsWithTokens(full, suffix) {
  if (suffix.length > full.length) return false;
  const off = full.length - suffix.length;
  for (let i = 0; i < suffix.length; i++) if (full[off + i] !== suffix[i]) return false;
  return true;
}

function overlapTokenCount(full, next) {
  const max = Math.min(full.length, next.length);
  for (let k = max; k > 0; k--) {
    let ok = true;
    for (let i = 0; i < k; i++) {
      if (full[full.length - k + i] !== next[i]) { ok = false; break; }
    }
    if (ok) return k;
  }
  return 0;
}


    function normalize(s) {
      return (s || "").replace(/\s+/g, " ").trim();
    }
    
    function commitTextareaToCommitted() {
      return new Promise((resolve) => {
        const doCommit = () => {
          committedText = textEl.value;  // raw edits
          interimText = "";
          lastFinalCanonTokens = [];
          segmentStart = committedText.length;
          renderTranscript();
          resolve();
        };
    
        // Force IME to commit on mobile
        if (document.activeElement === textEl) textEl.blur();
    
        // Wait a tiny moment (more reliable than 1 frame on many Android keyboards)
        setTimeout(doCommit, 0);
      });
    }



    function ensureSpace(base) {
      return base.length > 0 && !/\s$/.test(base) ? " " : "";
    }

    function renderTranscript() {
      const shouldStick = userPinnedToBottom && textEl.readOnly;
      textEl.value = (committedText + interimText).trimStart();
      if (shouldStick) textEl.scrollTop = textEl.scrollHeight;
    
      updateEmptyState();
    }


    function appendDeltaFromFinal(finalTextRaw) {
      const hypRaw = rawTokens(finalTextRaw);
      if (hypRaw.length === 0) return;
    
      const hypCanon = hypRaw.map(canonToken).filter(Boolean);
      const prevCanon = lastFinalCanonTokens;
    
      // 1) Growing prefix within the current stream (token-based, case/punct/accents tolerant)
      if (prevCanon.length > 0 && startsWithTokens(hypCanon, prevCanon)) {
        const tailRaw = hypRaw.slice(prevCanon.length).join(" ");
        if (tailRaw) committedText += ensureSpace(committedText) + tailRaw;
        lastFinalCanonTokens = hypCanon;
        return;
      }
    
      // 2) Regression: ignore
      if (prevCanon.length > 0 && startsWithTokens(prevCanon, hypCanon)) {
        return;
      }
    
      // 3) Restart/resegmentation: dedupe only within the current segment, canonically
      const segmentText = committedText.slice(segmentStart);
      const segCanon = canonTokensFromText(segmentText);
    
      // If the segment already ends with this hypothesis, it's a duplicate
      if (segCanon.length > 0 && endsWithTokens(segCanon, hypCanon)) {
        lastFinalCanonTokens = hypCanon;
        return;
      }
    
      // Otherwise append only the non-overlapping tail (token overlap)
      const ov = overlapTokenCount(segCanon, hypCanon);
      const tailRaw = hypRaw.slice(ov).join(" ");
      if (tailRaw) committedText += ensureSpace(committedText) + tailRaw;
    
      lastFinalCanonTokens = hypCanon;
    }


    function ensureRecognition() {
      if (!SpeechRecognition) return null;
      if (recog) return recog;

      recog = new SpeechRecognition();
      recog.continuous = true;
      recog.interimResults = true;
      recog.maxAlternatives = 1;

      recog.onresult = (event) => {
        let interim = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const r = event.results[i];
          const t = r[0]?.transcript ?? "";
          if (!t) continue;

          if (r.isFinal) appendDeltaFromFinal(t);
          else interim += t;
        }

        interimText = interim;
        renderTranscript();
      };

      recog.onerror = (e) => setStatus(`Recognition error: ${e.error}`);

      recog.onend = () => {
        if (recState === "listening" && !manualEnd) {
          setTimeout(() => {
            if (recState === "listening") {
              try { recog.start(); } catch (_) {}
            }
          }, 150);
        }
        manualEnd = false;
      };

      return recog;
    }

    function startRecognition({ clear }) {
      const r = ensureRecognition();
      if (!r) {
        setStatus("Speech recognition not supported in this browser.");
        return;
      }

      r.lang = langEl.value;

      if (clear) {
        committedText = "";
        interimText = "";
        lastFinalCanonTokens = [];
        segmentStart = 0;
        renderTranscript();
      } else {
        // If user edited manually, sync once
        // ✅ Always commit what's currently in the textarea (preserves edits even after leaving edit mode)


        // Ensure separation before new words after resume
        if (committedText && !/\s$/.test(committedText)) {
          committedText += " ";
          renderTranscript();
        }

        // New segment boundary (allows repeats like "...ça va" then "Ça va bien")
        segmentStart = committedText.length;
        lastFinalCanonTokens = [];
      }

      // Re-enable autoscroll following on Start/Resume
      userPinnedToBottom = true;

      recState = "listening";
      manualEnd = false;
      setStatus("Listening…");
      try { r.start(); } catch (_) {}
    }

    function pauseRecognition() {
      if (!recog) return;
      manualEnd = true;
      try { recog.stop(); } catch (_) {}
      recState = "idle";
      interimText = "";
      renderTranscript();
      setStatus("Paused.");
    }

    function stopRecognitionAndClear() {
      if (recog) {
        manualEnd = true;
        try { recog.stop(); } catch (_) {}
      }
      recState = "idle";
      committedText = "";
      interimText = "";
      lastFinalCanonTokens = [];
      segmentStart = 0;
      renderTranscript();
      setStatus("⋆.˚ ☾⭒.˚");
      shouldClearOnNextStart = true;
      userPinnedToBottom = true;
    }

    // ---------- Speech Synthesis ----------
    let currentUtterance = null;

    function getSelectedOrAllText() {
      const start = textEl.selectionStart;
      const end = textEl.selectionEnd;
      if (typeof start === "number" && typeof end === "number" && end > start) {
        return textEl.value.slice(start, end);
      }
      return textEl.value;
    }

    function speakText(text) {
      if (!text.trim()) return;

      window.speechSynthesis.cancel();

      const u = new SpeechSynthesisUtterance(text);
      u.lang = langEl.value;

      u.onend = () => {
        currentUtterance = null;
        playBtn.textContent = "PLAY";
        setStatus(recState === "listening" ? "Listening.." : "ᓚᘏᗢ");
      };
      u.onerror = () => {
        currentUtterance = null;
        playBtn.textContent = "PLAY";
        setStatus("TTS error.");
      };

      currentUtterance = u;
      playBtn.textContent = "STOP";
      setStatus("Speaking…");
      window.speechSynthesis.speak(u);
    }

    // ---------- Buttons ----------
    startBtn.onclick = async () => {
      const clear = shouldClearOnNextStart;
      shouldClearOnNextStart = false;
    
      if (!textEl.readOnly) {
        await commitTextareaToCommitted();
      }
      startRecognition({ clear });
    };



    stopBtn.onclick = () => {
      stopRecognitionAndClear();
      window.speechSynthesis.cancel();
      currentUtterance = null;
      playBtn.textContent = "PLAY";
    };

    pauseBtn.onclick = () => {
      if (recState === "listening") pauseRecognition();

      if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
        window.speechSynthesis.pause();
        setStatus("Paused.");
      } else if (recState !== "listening") {
        setStatus("Paused.");
      }
    };

resumeBtn.onclick = async () => {
  if (!textEl.readOnly) {
    await commitTextareaToCommitted();
  }
  if (recState !== "listening") startRecognition({ clear: false });

  if (window.speechSynthesis.paused) {
    window.speechSynthesis.resume();
    setStatus("Speaking…");
  }
};



    playBtn.onclick = () => {
      if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
        window.speechSynthesis.cancel();
        currentUtterance = null;
        playBtn.textContent = "PLAY";
        setStatus(recState === "listening" ? "Listening…" : "ᓚᘏᗢ");
        return;
      }
      speakText(getSelectedOrAllText());
    };

    // ---------- Edit toggle ----------
    let editing = false;
    editToggle.onclick = () => {
      editing = !editing;
      textEl.readOnly = !editing;
      editState.textContent = editing ? "ON" : "OFF";
    
      if (editing) {
        // Optional: stop recognition while editing
        if (recState === "listening") pauseRecognition();
        textEl.focus();
      } else {
        commitTextareaToCommitted();
      }
    };


    // ---------- Init ----------
    setStatus("ᓚᘏᗢ");
    updateEmptyState();
  })();
  </script>
</body>
</html>
