<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Speech recognition app</title>
<style>
  body{
    background:#f6ecf6;
    margin:0;
    font-family:sans-serif;
    overflow-x:hidden;   /* prevent horizontal scroll */
    overflow-y:auto;     /* allow vertical scroll */
  }

  .main-container{
    display:flex;
    flex-direction:column;
    align-items:center;
    min-height:100vh;
    padding:16px;
    box-sizing:border-box;
    gap:12px;
  }

  /* Keep all main blocks perfectly aligned */
  .lang-row,
  .controls,
  .status,
  #text{
    width:100%;
    max-width:700px;
    box-sizing:border-box;
  }

  /* Language selector full width like the textbox */
  .lang-row select{
    width:100%;
    background:#fff;
    color:#5f4e4f;
    border:2px solid #5f4e4f;
    border-radius:5px;
    padding:10px 12px;
    font-size:16px;
  }

  /* Controls layout: 3 rows (2 buttons / 1 button / 2 buttons) */
  .controls{
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .btn-row{
    display:grid;
    gap:10px;
  }
  .btn-row.two{ grid-template-columns:1fr 1fr; }
  .btn-row.one{ grid-template-columns:1fr; }

  button{
    width:100%;
    background:#5f4e4f;
    color:#fff;
    font-size:16px;
    padding:10px 12px;
    border:0;
    border-radius:5px;
    cursor:pointer;
  }
  button:disabled{
    opacity:.55;
    cursor:not-allowed;
  }

  #text{
    border:2px solid #5f4e4f;
    border-radius:5px;
    overflow:auto;
    resize:vertical;
    font-size:16px;
    padding:10px;
    min-height:50vh;
  }

  textarea:focus{
  outline: none;
  border: 2px #5f4e4f solid;
  box-shadow: 0 0 0 2px rgba(95,78,79,0.15);
}

  .status{
    color:#5f4e4f;
    font-size:14px;
    min-height:18px;
    user-select:none;
  }

  /* Optional small-screen tuning */
  @media (max-width:480px){
    .main-container{ padding:12px; }
    button{ font-size:15px; padding:10px 10px; }
  }

  .text-wrap{
  position: relative;
  width: 100%;
  max-width: 700px;
  box-sizing: border-box;
}

/* Keep your textarea full-width inside wrapper */
.text-wrap #text{
  width: 100%;
}

/* Small unobtrusive edit button */
.icon-btn{
  position: absolute;
  top: 8px;
  right: 8px;
  width: 36px;
  height: 36px;
  padding: 0;
  border-radius: 10px;
  border: 0;
  background: rgba(95,78,79,0.14);
  color: #5f4e4f;
  display: grid;
  place-items: center;
  cursor: pointer;
}

/* On tap/hover: slightly stronger */
.icon-btn:hover{ background: rgba(95,78,79,0.22); }
.icon-btn:active{ transform: scale(0.98); }

/* When in edit mode, make button look "active" */
.icon-btn.is-on{
  background: #5f4e4f;
  color: #fff;
}

</style>
</head>

<body>
  <div class="main-container">
        <!-- Language full-width row -->
    <div class="lang-row">
      <select id="langSelect" aria-label="Language">
        <option value="fr-FR" selected>Français</option>
        <option value="en-US">English</option>
      </select>
    </div>

    <!-- Buttons full-width, in 3 rows -->
    <div class="controls">
      <div class="btn-row two">
        <button id="btnStartNew">START</button>
        <button id="btnStop" disabled>STOP</button>
      </div>

      <div class="btn-row one">
        <button id="btnPlay">PLAY</button>
      </div>

      <div class="btn-row two">
        <button id="btnPause">PAUSE</button>
        <button id="btnResume" disabled>RESUME</button>
      </div>
    </div>
    <div class="status" id="status"></div>

    <div class="text-wrap">
      <button id="btnEdit" class="icon-btn" type="button" aria-label="Edit text" title="Edit">✎</button>
      <textarea id="text" readonly cols="30" rows="10" placeholder="Your text will appear here..."></textarea>
    </div>

  </div>

  <script>
    const btnStartNew = document.getElementById("btnStartNew");
    const btnPause    = document.getElementById("btnPause");
    const btnResume   = document.getElementById("btnResume");
    const btnStop     = document.getElementById("btnStop");
    const btnPlay     = document.getElementById("btnPlay");
    const langSelect  = document.getElementById("langSelect");
    const text        = document.getElementById("text");
    const statusEl    = document.getElementById("status");

    const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition;

    const btnEdit = document.getElementById("btnEdit");
    let isEditMode = false;

    btnEdit.addEventListener("click", () => {
      isEditMode = !isEditMode;
    
      if (isEditMode) {
        text.removeAttribute("readonly");
        btnEdit.classList.add("is-on");
        btnEdit.textContent = "✓";
        text.focus();           // keyboard opens intentionally
      } else {
        text.setAttribute("readonly", "");
        btnEdit.classList.remove("is-on");
        btnEdit.textContent = "✎";
        text.blur();            // hide keyboard
      }
    });


    let recognition = null;

    // state
    let sessionActive = false;     // started at least once, until STOP
    let isPaused = false;
    let keepAlive = false;         // auto-restart to allow long sessions
    let lastResultIndex = 0;
    let shouldCapitalizeNext = true;
    let pendingResume = false;
    let finalText = "";
    let lastFinal = "";
    let lastFinalAt = 0;



    function setStatus(msg){ statusEl.textContent = msg || ""; }

    function updateUI({listening=false, paused=false} = {}) {
      // START (new) is always available (it clears text)
      btnStartNew.disabled = false;

      // PAUSE available only while listening
      btnPause.disabled = !listening;

      // RESUME available only while paused
      btnResume.disabled = !paused;

      // STOP available while session active (listening or paused)
      btnStop.disabled = !sessionActive;

      // PLAY always available
      btnPlay.disabled = false;
    }

    function buildRecognition(){
      recognition = new SpeechRecognitionCtor();
      recognition.lang = langSelect.value;
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onstart = () => {
        setStatus("Listening…");
        updateUI({listening:true, paused:false});
      };

recognition.onresult = (event) => {
  let interim = "";

  // Normalize for matching: lowercase + collapse whitespace
  const norm = (s) => (s || "").toLowerCase().replace(/\s+/g, " ").trim();

  // Return how many chars of `bNorm` overlap with the end of `aNorm`
  const overlapLen = (aNorm, bNorm) => {
    const max = Math.min(aNorm.length, bNorm.length);
    for (let k = max; k > 0; k--) {
      if (aNorm.slice(-k) === bNorm.slice(0, k)) return k;
    }
    return 0;
  };

  for (let i = event.resultIndex; i < event.results.length; i++) {
    const result = event.results[i];
    const transcript = result[0].transcript || "";

    if (!result.isFinal) {
      interim += transcript;
      continue;
    }

    const now = Date.now();
    const tNorm = norm(transcript);

    // 1) Quick exact-repeat guard
    if (tNorm && tNorm === lastFinal && (now - lastFinalAt) < 2000) {
      continue;
    }
    lastFinal = tNorm;
    lastFinalAt = now;

    // 2) Overlap-safe append (prevents duplicates on mobile Edge)
    const ftNorm = norm(finalText);

    if (!tNorm) continue;

    // If the new transcript is entirely already contained at the end, skip
    if (ftNorm.endsWith(tNorm)) continue;

    // If the new transcript fully contains what we already have, replace with the new one
    // (some engines resend a "corrected" full chunk)
    if (tNorm.includes(ftNorm) && ftNorm.length > 0 && tNorm.length >= ftNorm.length) {
      finalText = transcript;
      if (!/[ \n]$/.test(finalText)) finalText += " ";
      continue;
    }

    // Append only the non-overlapping tail
    const k = overlapLen(ftNorm, tNorm);
    if (k > 0) {
      // We need to cut the ORIGINAL transcript in a way that corresponds to k normalized chars.
      // Do a best-effort: rebuild the tail by scanning original transcript tokens.
      const tokens = transcript.split(/\s+/);
      let builtNorm = "";
      let cutIndex = 0;

      for (let ti = 0; ti < tokens.length; ti++) {
        const nextNorm = norm((builtNorm ? builtNorm + " " : "") + tokens[ti]);
        if (nextNorm.length >= k) {
          cutIndex = ti; // overlap ends inside/at this token
          break;
        }
        builtNorm = (builtNorm ? builtNorm + " " : "") + tokens[ti];
      }

      // Tail starts after the overlap tokens (safe, may drop a tiny bit rather than duplicate)
      const tail = tokens.slice(cutIndex + 1).join(" ").trim();
      if (tail) {
        finalText += (finalText && !/[ \n]$/.test(finalText) ? " " : "") + tail;
        if (!/[ \n]$/.test(finalText)) finalText += " ";
      }
      continue;
    }

    // Fallback: no detectable overlap — append normally
    finalText += transcript;
    if (!/[ \n]$/.test(finalText)) finalText += " ";
  }

  text.value = finalText + interim;
};



      recognition.onerror = (event) => {
        console.log("Speech recognition error:", event.error);
        if (event.error === "not-allowed" || event.error === "service-not-allowed") {
          keepAlive = false;
          sessionActive = false;
          isPaused = false;
          setStatus("Microphone permission denied.");
          updateUI({listening:false, paused:false});
        } else if (!isPaused && keepAlive) {
          setStatus("Recognition error. Reconnecting…");
        }
      };

      recognition.onend = () => {
        if (pendingResume && sessionActive && !isPaused) {
          pendingResume = false;
          try { recognition.start(); } catch (e) {
            setTimeout(() => { try { recognition.start(); } catch(_){} }, 350);
          }
          return;
        }
        // If paused or stopped, don't restart
        if (!sessionActive || isPaused) {
          setStatus(isPaused ? "Paused." : "Stopped.");
          updateUI({listening:false, paused:isPaused});
          return;
        }

        // Keep-alive for long sessions
        if (keepAlive) {
          setStatus("Reconnecting…");
          try {
            recognition.start();
          } catch (e) {
            setTimeout(() => { try { recognition.start(); } catch(_){} }, 350);
          }
        }
      };
    }

    function ensureRecognition(){
      if (!SpeechRecognitionCtor) return false;
      if (!recognition) buildRecognition();
      recognition.lang = langSelect.value;
      return true;
    }

    function startNew(){
      window.speechSynthesis.cancel();
      btnPlay.textContent = "PLAY";
      if (!ensureRecognition()) return;

      // New recording: clear text
      finalText = "";
      text.value = "";
      lastResultIndex = 0;
      shouldCapitalizeNext = true;

      sessionActive = true;
      isPaused = false;
      keepAlive = true;

      setStatus("Listening…");
      updateUI({listening:true, paused:false});

      try { recognition.start(); } catch(e) { console.log(e); }
    }

    function pause(){
      if (!recognition || !sessionActive) return;

      // ✅ Keep user edits: make the textarea the source of truth
      finalText = text.value || "";
      if (finalText && !/[ \n]$/.test(finalText)) finalText += " ";

      // (recommended) reset dedupe state after manual edits
      lastFinal = "";
      lastFinalAt = 0;

      isPaused = true;
      keepAlive = false;

      setStatus("Paused.");
      updateUI({listening:false, paused:true});

      try { recognition.stop(); } catch(e) { console.log(e); }
    }


    function resume(){
      text.setAttribute("readonly", "");
      isEditMode = false;
      btnEdit.classList.remove("is-on");
      btnEdit.textContent = "✎";
      text.blur();
      if (!ensureRecognition() || !sessionActive) return;

      // ✅ Keep user edits (in case they edited while paused)
      finalText = text.value || "";
      if (finalText && !/[ \n]$/.test(finalText)) finalText += " ";

      // (recommended) reset dedupe state after manual edits
      lastFinal = "";
      lastFinalAt = 0;

      isPaused = false;
      keepAlive = true;
      pendingResume = false; // not used in your current resume logic

      setStatus("Listening…");
      updateUI({listening:true, paused:false});

      // Prevent "first phrase lost" by restarting a moment later
      lastResultIndex = 0;

      setTimeout(() => {
        try { recognition.start(); }
        catch (e) {
          // If it complains it's still stopping, retry once shortly after
          setTimeout(() => { try { recognition.start(); } catch(_){} }, 350);
        }
      }, 200);
    }




    function stop(){
      if (!recognition) return;

      sessionActive = false;
      isPaused = false;
      keepAlive = false;

      setStatus("Stopped.");
      updateUI({listening:false, paused:false});

      try { recognition.abort(); } catch(e) { console.log(e); }
    }

    btnStartNew.addEventListener("click", startNew);
    btnPause.addEventListener("click", pause);
    btnResume.addEventListener("click", resume);
    btnStop.addEventListener("click", stop);

    langSelect.addEventListener("change", () => {
      if (recognition) recognition.lang = langSelect.value;

      // If currently listening, restart quickly to apply language
      if (sessionActive && !isPaused) {
        keepAlive = false;
        try { recognition.stop(); } catch(_) {}
        setTimeout(() => {
          if (!sessionActive || isPaused) return;
          keepAlive = true;
          try { recognition.start(); } catch(_) {}
        }, 350);
      }
    });

btnPlay.addEventListener("click", () => {
  // Toggle stop if currently speaking
  if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
    window.speechSynthesis.cancel();
    btnPlay.textContent = "PLAY";
    return;
  }

  // Play selection if any, otherwise play all
  const start = text.selectionStart ?? 0;
  const end   = text.selectionEnd ?? 0;

  const selected = (start !== end) ? text.value.slice(start, end) : "";
  const toSpeak = selected.trim() ? selected : text.value;

  readText(toSpeak);
});



function readText(content){
  const value = (content || "").trim();
  if (!value) return;

  window.speechSynthesis.cancel(); // stop any previous speech

  const utter = new SpeechSynthesisUtterance(value);
  utter.lang = langSelect.value;
  utter.volume = 1;
  utter.rate = 1;
  utter.pitch = 1;

  // Update button label while speaking
  utter.onstart = () => { btnPlay.textContent = "STOP PLAYBACK"; };
  utter.onend   = () => { btnPlay.textContent = "PLAY"; };
  utter.onerror = () => { btnPlay.textContent = "PLAY"; };

  window.speechSynthesis.speak(utter);
}


    // Initialize UI
    if (!SpeechRecognitionCtor) {
      setStatus("SpeechRecognition not supported in this browser (try Chrome).");
      btnStartNew.disabled = true;
      btnPause.disabled = true;
      btnResume.disabled = true;
      btnStop.disabled = true;
    } else {
      setStatus("Ready.");
      updateUI({listening:false, paused:false});
    }
  </script>
</body>
</html>
